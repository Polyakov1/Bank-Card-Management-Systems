# Система Управления Банковскими Картами (Backend)

Backend-часть системы управления банковскими картами, разработанная в рамках тестового задания. Система обеспечивает создание, управление и просмотр данных о банковских картах, а также выполнение операций между картами пользователя с использованием REST API.

## Стек Технологий

*   **Язык:** Java 17
*   **Фреймворк:** Spring Boot 3.x
*   **Безопасность:** Spring Security (JWT аутентификация + Refresh Tokens)
*   **Работа с данными:** Spring Data JPA (Hibernate)
*   **База данных:** PostgreSQL (в Docker)
*   **Миграции БД:** Liquibase
*   **Документация API:** [OpenAPI 3 (Swagger UI)](https://springdoc.org/#getting-started)
*   **Сборка:** Maven 
*   **Контейнеризация:** Docker, Docker Compose
*   **Вспомогательные:** Lombok, MapStruct Spring Validation, Apache Commons Validator

## Функциональные Возможности (Кратко)

*   **Аутентификация/Авторизация:** JWT (Access + Refresh Tokens), Роли (ADMIN, USER), Регистрация.
*   **Карты:**
    *   Автоматическая генерация номеров (с проверкой по Луну).
    *   Шифрование номера карты (AES/GCM).
    *   Маскирование номера карты в API ответах.
    *   CRUD операции (с учетом ролей).
    *   Управление статусами (`ACTIVE`, `BLOCKED`, `EXPIRED`).
    *   Переводы между картами одного пользователя.
    *   Просмотр баланса (одной карты / общий).
    *   Параметризованная фильтрация и пагинация списков.
*   **Управление пользователями (Admin):** CRUD операции над пользователями через `/api/admin/users`.

## Статусы Карт
*   `ACTIVE`: Карта активна и может использоваться для операций.
*   `BLOCKED`: Карта заблокирована администратором. Неактивна для операций.
*   `EXPIRED`: Срок действия карты истек. Неактивна для операций.

## Безопасность
*   Аутентификация по email/паролю с использованием JWT и Refresh Tokens.
*   Разделение прав доступа на основе ролей (ADMIN, USER).
*   Номера карт хранятся в базе данных в **зашифрованном** виде (AES/GCM).
*   Номера карт **маскируются** при отображении через API (`**** **** **** 1234`).
*   Пароли пользователей хранятся в виде **хешей** (BCrypt).
*   Валидация входящих данных.
*   Централизованная обработка ошибок.

## Настройка и Запуск (Локально через Docker Compose)

### Требования
*   Java 17+ JDK
*   Gradle 7+ (или новее)
*   Docker
*   Docker Compose

### Инструкции по запуску
1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/Polyakov1/Bank-Card-Management-Systems
    cd card-management-system
    ```
2.  **(Важно!) Настройте секреты:**
    В файле `src/main/resources/application.yml` (или через переменные окружения при запуске `docker-compose`) необходимо задать безопасные значения для:
    *   `app.jwt.secret`: Секрет для подписи JWT (Base64-encoded, рекомендуемая длина >= 256 бит).
    *   `app.encryption.key`: Ключ для шифрования номеров карт (строка длиной **ровно 32 символа** для AES-256).

3.  **Соберите проект:**
    ```bash
    ./gradlew clean build
    ```
    Это создаст исполняемый JAR-файл в директории `build/libs`.

4.  **Запустите сервисы с помощью Docker Compose:**
    ```bash
    docker-compose up --build
    ```
    *   Параметр `--build` пересобирает образ приложения, если были изменения в коде или Dockerfile.
    *   Docker Compose поднимет контейнер с PostgreSQL и контейнер с вашим Spring Boot приложением. Liquibase автоматически применит миграции БД при первом запуске приложения.

5.  **Приложение будет доступно по адресу:** `http://localhost:8080`

## Доступ к API и Тестовые Данные
*   **Swagger UI (Документация API):** `http://localhost:8080/swagger-ui/index.html#/`
*   **Тестовые пользователи** (создаются через Liquibase миграцию `002-add-test-users.xml`):
    *   Администратор:
        *   Email: `admin@example.com`
        *   Пароль: `admin`
    *   Пользователь:
        *   Email: `user@example.com`
        *   Пароль: `password`
*   **Регистрация:**
    *   Доступен эндпоинт `POST /api/auth/register` для создания новых пользователей (с ролью `USER`).
    *   Пример тела запроса:
        ```json
        {
          "email": "new.user@example.com",
          "password": "password123"
        }
        ```
*   **Использование API:**
    1.  Перейдите в Swagger UI.
    2.  Используйте эндпоинт `POST /api/auth/login` для получения `accessToken` и `refreshToken`.
    3.  Скопируйте `accessToken`.
    4.  Нажмите кнопку "Authorize" в правом верхнем углу Swagger UI.
![img.png](swagger-to-authorize.png)
     5.  Вставьте `accessToken` в поле "Value" (например: `eyJhbGciOi...`).
     6.  Нажмите "Authorize" и "Close".
     7.  Теперь вы можете выполнять запросы к защищенным эндпоинтам.
     8.  Когда `accessToken` истечет, используйте эндпоинт `POST /api/auth/refresh` с вашим `refreshToken` для получения новой пары токенов.

## TODO / Возможные Улучшения
* Планировщик задач (Scheduler) для очистки старых Refresh Tokens или установки статуса EXPIRED для карт.
* Повысить покрытие тестами
